## 任务 ##
给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。

示例 1：

    输入: "babad"  
    输出: "bab"  
    注意: "aba" 也是一个有效答案。  

## 关键思路 ##
**思路1：最长公共子串**

> 反转 SS，使之变成 S'S ′。找到 SS 和 S'S ′之间最长的公共子串，这也必然是最长的回文子串。

但是对于例子：

    S=“abacdfgdcaba”, S' = “abacdgfdcaba”  
    S 以及 S'之间的最长公共子串为 abacd。显然，这不是回文。

 即S 的其他部分中存在非回文子串的反向副本时，最长公共子串法就会失败。  
为了纠正这一点，每当我们找到最长的公共子串的候选项时，都需要**检查子串的索引是否与反向子串的原始索引相同**。如果相同，那么我们尝试更新目前为止找到的最长回文子串；如果不是，我们就跳过这个候选项并继续寻找下一个候选。



**思路2：动态规划**

为了改进暴力法，我们首先观察如何避免在验证回文时进行不必要的重复计算。考虑 ababa 这个示例。如果我们已经知道 bab是回文，那么很明显，ababa一定是回文，因为它的左首字母和右尾字母是相同的。

我们给出 P(i,j)的定义如下：

    P(i,j) = true, 如果子串是回文子串
    P(i,j) = false,其它情况
​	
因此，

    P(i, j) = ( P(i+1, j-1)  and  S_i == S_j )
    

基本示例如下：


    P(i,i)=true
    
    P(i, i+1) = ( S_i == S_i+1 )


这产生了一个直观的动态规划解法，我们首先初始化一字母和二字母的回文，然后找到所有三字母回文，并依此类推…

**思路3：中心扩展算法**

事实上，只需使用恒定的空间，我们就可以在 O(n^2)的时间内解决这个问题。

我们观察到回文中心的两侧互为镜像。因此，回文可以从它的中心展开，并且只有2n−1 个这样的中心。

你可能会问，为什么会是2n−1 个，而不是 n 个中心？原因在于所含字母数为偶数的回文的中心可以处于两字母之间（例如 “abba” 的中心在两个 ‘b’ 之间）。

中心扩散法的想法很简单：遍历每一个索引，以这个索引为中心，利用“回文串”中心对称的特点，往两边扩散，看最多能扩散多远。要注意一个细节：回文串的长度可能是奇数，也可能是偶数。

[https://leetcode-cn.com/problems/longest-palindromic-substring/solution/zhong-xin-kuo-san-dong-tai-gui-hua-by-liweiwei1419/](https://leetcode-cn.com/problems/longest-palindromic-substring/solution/zhong-xin-kuo-san-dong-tai-gui-hua-by-liweiwei1419/)
