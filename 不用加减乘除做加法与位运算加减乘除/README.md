## 任务 ##
写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。

##关键思路##
**逻辑位运算**   
3步走：  
**两个数异或：求个位：相当于每一位相加，而不考虑进位； ^ 异或**  
**两个数相与，并左移一位：相当于求得进位：  & 与**   
将上述两步的结果相加  **

由于题目要求不能使用四则运算，那么就需要考虑使用位运算  
两个数相加可以看成**两个数的每个位先相加**，**但不进位**，然后在加**上进位的**数值  

     如12+8可以看成1+0=1 2+8=0，由于2+8有进位，所以结果就是10+10=20  
     二进制中可以表示为1000+1100 先每个位置相加不进位，  
     则0+0=0 0+1=1 1+0=1 1+1=0这个就是按位异或运算  
     对于1+1出现进位，我们可以使用按位与运算然后在将结果左移一位
     最后将上面两步的结果相加，相加的时候依然要考虑进位的情况，直到不产生进位
注意python没有无符号右移操作，**所以需要越界检查**

**按位与运算：**相同位的两个数字都为1，则为1；若有一个不为1，则为0。  
**按位异或运算：**相同位不同则为1，相同则为0。

**~运算符**除了求反，还是二进制的补运算符，运算过后的二进制数字按照补码解释。

    class Solution:
   		 def Add(self, num1, num2):
   
   		 while num2:
   		 	result = (num1 ^ num2) & 0xffffffff
   		 	carry = ((num1 & num2) << 1) & 0xffffffff
   			num1 = result
   			num2 = carry
   		 if num1 <= 0x7fffffff:
   			 result = num1
   		 else:
   		 	result = ~(num1^0xffffffff)
   		 return result
    



在Python内部对整数的处理分为普通整数和长整数，**普通整数长度**为机器位长，通常都**是32位**，超过这个范围的整数就自动当长整数处理，而长整数的范围几乎完全没限制。**当-1 + -6 通过while中的位运算操作之后，输出的计算结果是4294967289。经过~(num1^0xffffffff)这个操作会被作为负数解释输出**，~运算符除了求反，还是二进制的补运算符，运算过后的二进制数字按照补码解释。就可以输出负数了。

减法运算

　　实现a - b只要实现a + (-b)即可。所以只要将a和b的相反数调用add函数就行。根据二进制数在机器中表达的规则，得到一个数的相反数，就是这个数的二进制数表达取反加1（补码）的结果。

乘法运算

　　用位运算实现乘法运算。a × b的结果可以写成 a∗20∗b0+a∗21∗b1+...a∗2i∗bi+...a∗231∗b31a∗20∗b0+a∗21∗b1+...a∗2i∗bi+...a∗231∗b31. 其中bi为0或1表示整数b的二进制表达中第i位的值（从右往左数）。该过程有点类似于求整数的N次方问题。

除法运算

　　用位运算实现除法运算其实就是乘法的逆运算。定义 res 表示除法的结果。首先将a向右移位31位，然后看能不能容下b，如果能，说明a/231a/231可以包含一个b，等价于a可以包含一个b∗231b∗231，令res的第31位为1，此时a的值应该为a−b∗231a−b∗231；如果不能容下b，令res的第31位为0，a的值不变；接下来将a向右移位30位是否能容下b……重复步骤直到a−b∗2i=0a−b∗2i=0。 
　　以上过程只适用于a和b都不是负数的情况下，当a或b为负数时，可以先将a和b转成正数，计算完之后再判断res的真实符号就行。 
　　除法实现到这一步已经可以解决绝大多数情况了。但是我们知道，32位最小整数的绝对值要比最大整数大，所以如果a或b等于最小值，是不能转换成相对应的正数的。这时候需要分情况考虑：

如果a和b都为最小值，直接返回1

如果a不为最小值，而b为最小值，那么a/b = 0，直接返回0

如果a为最小值，而b不为最小值。这时我们对a无能为力，但是我们可以让a增大一点点，计算出一个结果然后再修正一下就可以得到最终的结果。处理过程如下：

　　<1>计算(a+1)/b(a+1)/b，结果记为c   
　　<2>计算c∗bc∗b   
　　<3>计算(a−c∗b)/b(a−c∗b)/b，结果记为rest   
　　<4>计算c+rest  
