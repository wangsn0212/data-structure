## 任务 ##
输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）

## 关键思路 ##
1. 方法1

第一步递归调用HasSubtree遍历二叉树A。如果发现某一节点的值和树B的根结点的值相等，则调用DoesTree1HaveTree2,进行第二步判断。  

第二步是判断树A中以R为跟结点的子树是不是和树B具有相同的结构。  
>    同样，也可以用递归的思路来考虑：  

     如果节点R的值和树B的根节点不同，那么以R为根节点的子树和树B肯定不具有相同的节点；
        
     如果它们的值相同，那么递归地判断它们各自的左右节点的值是不是相同。
  
     递归的终止条件是到达了树A或者树B的叶子节点。  
>      
      需要注意的是  DoesTree1HasTree2函数中，如果Tree2为空，则说明第二棵树遍历完了  
      即是第一颗树的子树，返回TRUE    
      如果tree1为空而tree2不为空说明tree2结构超大，tree1中不存在

2. 方法2相同


算法实现思路：对于两棵二叉树来说，要判断B是不是A的子结构，首先第一步在树A中查找与B根节点的值一样的节点。

通常对于查找树中某一个节点，我们都是采用递归的方法来遍历整棵树。

第二步就是判断树A中以R为根节点的子树是不是和树B具有相同的结构。

这里同样利用到了递归的方法，如果节点R的值和树的根节点不相同，则以R为根节点的子树和树B肯定不具有相同的节点；

如果它们值是相同的，则递归的判断各自的左右节点的值是不是相同。

递归的终止条件是我们达到了树A或者树B的叶节点。

有地方要重点注意，DoesTree1haveTree2()函数中的两个 if 判断语句 不能颠倒顺序 。
因为如果颠倒了顺序，会先判断pRoot1 是否为None, 其实这个时候，pRoot1 的节点已经遍历完成确认相等了，但是这个时候会返回 False，判断错误。


## 关键词         
**二叉树**


1. 深度优先遍历： 先根序（DLR），中根序（LDR，也称对称序），后根序（LRD） 
2. 宽度优先遍历：逐层从左到右访问

**堆：完全二叉树形结构实现优先队列**  
优先级最高元素位于堆顶，从树根到叶结点，优先关系应为（非严格）递减。  
小顶堆：最小元素优先  
大顶堆：最大元素优先

插入元素和向上筛选： 新加入元素自底向上不断比较，直到找到合适位置，可在O(log n)时间完成  
弹出元素和向下筛选： 弹出堆顶元素后，变为左右2堆，则添加一元素，使用向下筛选重新合为一堆。  
     弹出操作步骤：     
   
      1. 弹出当时的堆顶   O(1)
      2. 从堆最后取一个元素作为完全二叉树的跟   O(1)
      3. 执行一次向下筛选    O(log n)

类内函数调用需要加 self.函数名 ，否则可能调用类外函数。
