## 冒泡排序 ##
[https://www.cnblogs.com/fwl8888/p/9315730.html](https://www.cnblogs.com/fwl8888/p/9315730.html "图示讲解")


冒泡排序（英语：Bubble Sort）是一种简单的排序算法。它重复地遍历要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。遍历数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为**越小的元素会经由交换慢慢“浮**”到数列的顶端。

**算法思路：**

> 比较相邻的元素。如果第一个比第二个大（升序），就交换他们两个。  
> 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。  
> 针对所有的元素重复以上的步骤，除了最后一个。  
> 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。  

**时间复杂度：**  
最优时间复杂度：O(n) （表示遍历一次发现没有任何可以交换的元素，排序结束。）  
最坏时间复杂度：O(n2)  
稳定性：稳定  

## 选择排序 ##


选择排序（Selection sort）是一种简单直观的排序算法。
选择排序的主要优点与数据移动有关。如果某个元素位于正确的最终位置上，则它不会被移动。选择排序每次交换一对元素，它们当中至少有一个将被移到其最终位置上，因此对n个元素的表进行排序总共进行至多n-1次交换。在所有的完全依靠交换去移动元素的排序方法中，选择排序属于非常好的一种。

**算法思路：**

>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，  
>然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。  
>以此类推，直到所有元素均排序完毕。  
>
>(注： 调换数字的位置进行排序)  
>指针记录最小值index

**时间复杂度：**  
最优时间复杂度：O(n2)  
最坏时间复杂度：O(n2)  
稳定性：不稳定（考虑升序每次选择最大的情况  

## 插入排序 ##


插入排序（英语：Insertion Sort）是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。

**算法思路：**

>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，  
>然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。  
>以此类推，直到所有元素均排序完毕。  
>
>(注： 调换数字的位置进行排序)  
>指针记录最小值index

**时间复杂度：**  
最优时间复杂度：O(n) （升序排列，序列已经处于升序状态）  
最坏时间复杂度：O(n2)  
稳定性：稳定  


**！！选择排序，每次只改变互换元素的位置，插入排序会改变一系列的后移**


## 快速排序 ##


快速排序（英语：Quicksort），又称划分交换排序（partition-exchange sort），通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。

**算法思路：**

>从数列中挑出一个元素，称为"基准"（pivot），   
>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区结束之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。  
>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。

**时间复杂度：**  
最优时间复杂度：O(nlogn)  
最坏时间复杂度：O(n2)  
稳定性：不稳定  
从一开始快速排序平均需要花费O(n log n)时间的描述并不明显。但是不难观察到的是分区运算，数组的元素都会在每次循环中走访过一次，使用O(n)的时间。在使用结合（concatenation）的版本中，这项运算也是O(n)。

在最好的情况，每次我们运行一次分区，我们会把一个数列分为两个几近相等的片段。这个意思就是每次递归调用处理一半大小的数列。因此，在到达大小为一的数列前，我们只要作log n次嵌套的调用。这个意思就是调用树的深度是O(log n)。但是在同一层次结构的两个程序调用中，不会处理到原来数列的相同部分；因此，程序调用的每一层次结构总共全部仅需要O(n)的时间（每个调用有某些共同的额外耗费，但是因为在每一层次结构仅仅只有O(n)个调用，这些被归纳在O(n)系数中）。结果是这个算法仅需使用O(n log n)时间。

    注:以序列的第一个为基准，从右往左遍历(j)，找到第一个比基值小的数，放入基值位置（同时空出一个位置）；  

    然后从左往右遍历（i）,找到第一个比基值打的数，放入空出位置（同时空出一个位置）；  

    不断循环至i=j，此时把基值放到此位置，为此值最终位置。而后，递归该值左右

## 希尔排序 ##


希尔排序(Shell Sort)是插入排序的一种。也称缩小增量排序，是直接插入排序算法的一种更高效的改进版本。希尔排序是非稳定排序算法。该方法因DL．Shell于1959年提出而得名。 希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。

**算法思路：**

希尔排序的基本思想是：将数组列在一个表中并对列分别进行插入排序，重复这过程，不过每次用更长的列（步长更长了，列数更少了）来进行。最后整个表就只有一列了。将数组转换至表是为了更好地理解这算法，算法本身还是使用数组进行排序。

**时间复杂度：**  
最优时间复杂度：根据步长序列的不同而不同
最坏时间复杂度：O(n2)
稳定想：不稳定  


！！！步长选择，分为len/2,  /2 ... 至1，如序列下标为  

    1,2,3,4,5,6,7,8,9,10
    第一轮： 以5为步长，对比换值， 即1&6,2&7,3&8,4&9,5&10
    第二轮：针对上一轮得出的序列，以2步长换值对比，即1&3&5*7&9，2&4&6&8&10  
    第三轮： 针对上一轮得出的序列，以1步长换值对比，（对比为逐值对比：12,23,34，不是13,14,此类）

## 归并排序 ##


归并排序是采用分治法的一个非常典型的应用。归并排序的思想就是先递归分解数组，再合并数组。

**算法思路：**

将数组分解最小之后，然后合并两个有序数组，基本思路是比较两个数组的最前面的数，谁小就先取谁，取了后相应的指针就往后移一位。然后再比较，直至一个数组为空，最后把另一个数组的剩余部分复制过来即可。

    1.设长度为8，先全部打散为8个元素，8*1
    2.两两合并排序，变为，4*2
    3.以上基础两两合并排序，变为，2*4
    4.再合并排序，获得1*8
    股并排序规则：先对比两个序列第一个元素大小，即i = 0, j = 0, 选取最小的后，对应指针+1， 继续比较i,j对应元素，知道，两个序列为空完全两序列合并  


**时间复杂度：**  
最优时间复杂度：O(nlogn)
最坏时间复杂度：O(nlogn)
稳定性：稳定
