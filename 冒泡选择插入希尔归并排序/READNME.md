## 冒泡排序 ##
[https://www.cnblogs.com/fwl8888/p/9315730.html](https://www.cnblogs.com/fwl8888/p/9315730.html "图示讲解")


冒泡排序（英语：Bubble Sort）是一种简单的排序算法。它重复地遍历要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。遍历数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为**越小的元素会经由交换慢慢“浮**”到数列的顶端。

**算法思路：**

> 比较相邻的元素。如果第一个比第二个大（升序），就交换他们两个。  
> 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。  
> 针对所有的元素重复以上的步骤，除了最后一个。  
> 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。  

**时间复杂度：**  
最优时间复杂度：O(n) （表示遍历一次发现没有任何可以交换的元素，排序结束。）  
最坏时间复杂度：O(n2)  
稳定性：稳定  

## 选择排序 ##


选择排序（Selection sort）是一种简单直观的排序算法。
选择排序的主要优点与数据移动有关。如果某个元素位于正确的最终位置上，则它不会被移动。选择排序每次交换一对元素，它们当中至少有一个将被移到其最终位置上，因此对n个元素的表进行排序总共进行至多n-1次交换。在所有的完全依靠交换去移动元素的排序方法中，选择排序属于非常好的一种。

**算法思路：**

>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，  
>然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。  
>以此类推，直到所有元素均排序完毕。  
>
>(注： 调换数字的位置进行排序)  
>指针记录最小值index

**时间复杂度：**  
最优时间复杂度：O(n2)  
最坏时间复杂度：O(n2)  
稳定性：不稳定（考虑升序每次选择最大的情况  

## 插入排序 ##


插入排序（英语：Insertion Sort）是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。

**算法思路：**

>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，  
>然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。  
>以此类推，直到所有元素均排序完毕。  
>
>(注： 调换数字的位置进行排序)  
>指针记录最小值index

**时间复杂度：**  
最优时间复杂度：O(n) （升序排列，序列已经处于升序状态）  
最坏时间复杂度：O(n2)  
稳定性：稳定  


**！！选择排序，每次只改变互换元素的位置，插入排序会改变一系列的后移**


## 快速排序 ##


快速排序（英语：Quicksort），又称划分交换排序（partition-exchange sort），通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。

**算法思路：**

>从数列中挑出一个元素，称为"基准"（pivot），   
>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区结束之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。  
>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。

**时间复杂度：**  
最优时间复杂度：O(nlogn)  
最坏时间复杂度：O(n2)  
稳定性：不稳定  
从一开始快速排序平均需要花费O(n log n)时间的描述并不明显。但是不难观察到的是分区运算，数组的元素都会在每次循环中走访过一次，使用O(n)的时间。在使用结合（concatenation）的版本中，这项运算也是O(n)。

在最好的情况，每次我们运行一次分区，我们会把一个数列分为两个几近相等的片段。这个意思就是每次递归调用处理一半大小的数列。因此，在到达大小为一的数列前，我们只要作log n次嵌套的调用。这个意思就是调用树的深度是O(log n)。但是在同一层次结构的两个程序调用中，不会处理到原来数列的相同部分；因此，程序调用的每一层次结构总共全部仅需要O(n)的时间（每个调用有某些共同的额外耗费，但是因为在每一层次结构仅仅只有O(n)个调用，这些被归纳在O(n)系数中）。结果是这个算法仅需使用O(n log n)时间。

    注:以序列的第一个为基准，从右往左遍历(j)，找到第一个比基值小的数，放入基值位置（同时空出一个位置）；  

    然后从左往右遍历（i）,找到第一个比基值打的数，放入空出位置（同时空出一个位置）；  

    不断循环至i=j，此时把基值放到此位置，为此值最终位置。而后，递归该值左右

## 希尔排序 ##


希尔排序(Shell Sort)是插入排序的一种。也称缩小增量排序，是直接插入排序算法的一种更高效的改进版本。希尔排序是非稳定排序算法。该方法因DL．Shell于1959年提出而得名。 希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。

**算法思路：**

希尔排序的基本思想是：将数组列在一个表中并对列分别进行插入排序，重复这过程，不过每次用更长的列（步长更长了，列数更少了）来进行。最后整个表就只有一列了。将数组转换至表是为了更好地理解这算法，算法本身还是使用数组进行排序。

**时间复杂度：**  
最优时间复杂度：根据步长序列的不同而不同
最坏时间复杂度：O(n2)
稳定想：不稳定  


！！！步长选择，分为len/2,  /2 ... 至1，如序列下标为  

    1,2,3,4,5,6,7,8,9,10
    第一轮： 以5为步长，对比换值， 即1&6,2&7,3&8,4&9,5&10
    第二轮：针对上一轮得出的序列，以2步长换值对比，即1&3&5*7&9，2&4&6&8&10  
    第三轮： 针对上一轮得出的序列，以1步长换值对比，（对比为逐值对比：12,23,34，不是13,14,此类）

## 归并排序 ##


归并排序是采用分治法的一个非常典型的应用。归并排序的思想就是先递归分解数组，再合并数组。

**算法思路：**

将数组分解最小之后，然后合并两个有序数组，基本思路是比较两个数组的最前面的数，谁小就先取谁，取了后相应的指针就往后移一位。然后再比较，直至一个数组为空，最后把另一个数组的剩余部分复制过来即可。
归并排序：

    先分开再合并，分开成单个元素，合并的时候按照正确顺序合并
    
    假如我们有一个n个数的数列，下标从0到n-1

　　首先是分开的过程

    1 我们按照 n//2 把这个数列分成两个小的数列
    2 把两个小数列 再按照新长度的一半 把每个小数列都分成两个更小的
    。。。一直这样重复，一直到每一个数分开了
    比如：    6 5 4 3 2 1
        第一次 n=6 n//2=3 分成      6 5 4      3 2 1
        第二次 n=3 n//2=1 分成    6   5 4    3   2 1
        第三次 n=1的部分不分了
                n=2 n//2=1 分成     5   4      2  1
                
之后是合并排序的过程：

    3 分开之后我们按照最后分开的两个数比较大小形成正确顺序后组合绑定
        刚刚举得例子 最后一行最后分开的数排序后绑定   变成     4 5     1 2
        排序后倒数第二行相当于把最新分开的数排序之后变成    6   4 5       3    12
    4 对每组数据按照上次分开的结果，进行排序后绑定
        6 和 4 5(两个数绑定了)  进行排序
        3 和 1 2(两个数绑定了)  进行排序
        排完后 上述例子第一行待排序的  4 5 6      1 2 3  两组数据
    5 对上次分开的两组进行排序
        拿着 4 5 6     1 2 3两个数组，进行排序，每次拿出每个数列中第一个(最小的数)比较，把较小的数放入结果数组。再进行下一次排序。
        每个数组拿出第一个数，小的那个拿出来放在第一位 1 拿出来了，   变成4 5 6    2 3
        每个数组拿出第一个书比较小的那个放在下一个位置  1 2被拿出来，  待排序 4 5 6      2
        每个数组拿出第一个书比较小的那个放在下一个位置  1 2 3 被拿出来，  待排序 4 5 6
        如果一个数组空了，说明另一个数组一定比排好序的数组最后一个大 追加就可以结果 1 2 3 4 5 6
    相当于我们每次拿到两个有序的列表进行合并，分别从两个列表第一个元素比较，把小的拿出来，在拿新的第一个元素比较，把小的拿出来
        这样一直到两个列表空了 就按顺序合并了两个列表
    股并排序规则：先对比两个序列第一个元素大小，即i = 0, j = 0, 选取最小的后，对应指针+1， 继续比较i,j对应元素，知道，两个序列为空完全两序列合并  


**时间复杂度：**  
最优时间复杂度：O(nlogn)
最坏时间复杂度：O(nlogn)
稳定性：稳定
