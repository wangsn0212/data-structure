## 任务 ##
输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。

## 关键思路 ##

- 非递归算法

二叉搜索树中序遍历得，所有节点值得从小到大排列。  
故此：  
>1. 先中序遍历，将所有的节点保存到一个列表中。  
2. 对这个list[:-1]进行遍历，每个节点的right设为下一个节点，left设为上一个节点


- 递归算法
>
1.将左子树构造成双链表，并返回链表头节点。  
2.定位至左子树双链表最后一个节点。  
3.如果左子树链表不为空的话，将当前root追加到左子树链表。  
4.将右子树构造成双链表，并返回链表头节点。  
5.如果右子树链表不为空的话，将该链表追加到root节点之后。  
6.根据左子树链表是否为空确定返回的节点。  



算法实现思路：对于两棵二叉树来说，要判断B是不是A的子结构，首先第一步在树A中查找与B根节点的值一样的节点。

通常对于查找树中某一个节点，我们都是采用递归的方法来遍历整棵树。

第二步就是判断树A中以R为根节点的子树是不是和树B具有相同的结构。

这里同样利用到了递归的方法，如果节点R的值和树的根节点不相同，则以R为根节点的子树和树B肯定不具有相同的节点；

如果它们值是相同的，则递归的判断各自的左右节点的值是不是相同。

递归的终止条件是我们达到了树A或者树B的叶节点。

有地方要重点注意，DoesTree1haveTree2()函数中的两个 if 判断语句 不能颠倒顺序 。
因为如果颠倒了顺序，会先判断pRoot1 是否为None, 其实这个时候，pRoot1 的节点已经遍历完成确认相等了，但是这个时候会返回 False，判断错误。


## 关键词         
**1. 二叉搜索树**  

二叉查找树，（二叉搜索树，二叉排序树）它或者是一棵空树，或者是具有下列性质的二叉树：   
若它的**左子树不空**，则左子树上所有结点的值均**小于它的根结点的值**；
若它的**右子树不空**，则右子树上所有结点的值**均大于它的根结点的值**；  
它的**左、右子树也分别为二叉排序树。**  
二叉搜索树中序遍历，得从小到大排列

**2. 双向链表与二叉树**

双向链表是指除了首尾节点，其他节点都能访问他的前节点和后节点。  
二叉树链表就是二叉树，每个节点只能访问他的左右孩子节点，不能向上访问他的父节点，所以二叉树是单向的。

若将某一链表利用二叉树的形式实现双向链表，则把b点的上一节点a，与下一节点c分别作为该点的左右孩子节点，实现链表结构中的前后节点都能访问。
